
# 一、 并发与并行

## 1. 什么是并发？

同一个时间间隔（某个时间段内）有多个事件发生

## 2. 什么是并行？

同一个时刻有多个事件发生

## 3. 并发与并行的区别

+ 举个栗子：

> 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</br></br>
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。  （不一定是同时的）</br></br>
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

+ 并发不一定是并行，并行一定是并发；
+ 并发编程的目标是充分利用处理器的每一个核，以达到最高的处理性能

# 二、 线程

## 1. 线程的实现

## 2. 线程的状态

## 3. 优先级

## 4. 线程调度

## 5. 创建线程的多种方式

## 6. 守护线程

## 7. 线程与进程的区别和关系

# 三、 线程池

## 1. 自己设计线程池

## 2. submit()和execute()

## 3. 线程池原理

## 4. 为什么不允许使用Executors创建线程池

# 四、 线程安全

## 1. 死锁

## 2. 死锁如何排查

## 3. 线程安全和内存模型的关系

# 五、 锁

## 1. CAS

## 2. 乐观锁与悲观锁

## 3. 数据库相关锁机制

## 4. 分布式锁

## 5. 偏向锁

## 6. 轻量级锁

## 7. 重量级锁

## 8. monitor

## 9. 锁优化

### 9.1. 锁消除

### 9.2. 锁粗化

### 9.3. 自旋锁

### 9.4. 可重入锁

## 10. 阻塞锁

# 六、 死锁

## 1. 死锁的原因

## 2. 死锁的解决办法

# 七、 synchronized

## 1. synchronized是如何实现的

## 2. synchronized和lock之间的关系

## 3. 不用synchronized如何实现一个线程安全的单例

## 4. synchronized和原子性，可见性，和有序性之间的关系

# 八、 volatile

## 1. happens-before

## 2. 内存屏障

## 3. 编译器指令重排和CPU指令重排

## 4. volatile的实现原理

## 5. volatile和原子性，可见性，和有序性之间的关系

## 6. 有了synchronized为什么还需要volatile

# 九、 并发包

## 1. Thread

## 2. Runnable

## 3. callable

## 4. ReentrantLock

## 5. ReentrantReadWriteLock

## 6. Atom*

## 7. Semaphore

## 8. CountDownLatch

## 9. ConcurrentHashMap

## 10. Executors

# 十、 其他

## 1. sleep和wait

## 2. wait和notify

## 3. notify和notifyAll

## 4. ThreadLocal

## 5. 写一个死锁的程序

## 6. 写代码解决生产者消费者问题
